import os
from pathlib import Path
import csv
from PIL import Image, ImageFilter, ImageDraw
from torchvision.transforms import functional
from tqdm import tqdm  # for progress bar
import numpy as np


def clear_output_dir(output_dir):
    """Deletes all the pictures in the output directory.
    Args:
        output_dir (str): Directory to clear.
    """
    
    # Iterate through all files in the directory
    for filename in os.listdir(output_dir):
        # Check if the file is a .jpg or .png file
        if filename.endswith(".jpg") or filename.endswith(".JPG"):
            file_path = os.path.join(output_dir, filename)
            try:
                if os.path.isfile(file_path):
                    os.remove(file_path)
            except Exception as e:
                print(f"Error deleting file {file_path}: {e}")
    
    print(f"All images in {output_dir} have been deleted.")


def resize_training_images(target_size, image_directories, output_dir):
    """Loads all the training images (including the reference) and resizes them to the target size using PIL.
    The images are then saved in a new folder called 'synthetic'.

    Args:
        target_size (tuple, optional): New size of the images.
        images (list, optional): List of directories paths that contains image to resize.
        output_dir (str, optional): Directory to save the resized images.
    """
    
    # Input directories
    paths = []
    for dir in image_directories:
        paths.append(Path(dir))
    
    # Output directory
    resized_output_path = Path(output_dir)
    resized_output_path.mkdir(parents=True, exist_ok=True)
        
    # Load and resize training images
    for path in paths:
        print(f"Resizing images in {path}...")
        # read the whole directory and keep only the JPG files
        img_names = sorted(path.glob("*.JPG"))
        for img_name in tqdm(img_names):
            img = Image.open(img_name).convert("RGB")
            img = img.resize(target_size, Image.LANCZOS)
            img_file_name = img_name.stem + img_name.suffix
            # if the file name doesn't start with L, we add it
            if not img_file_name.startswith("L"):
                img_file_name = "L" + img_file_name
            img.save(resized_output_path / img_file_name)    
    
    print(f"DONE! Resized images saved in {resized_output_path}.")


def flip_images(initial_csv, image_dir_path, output_csv_path):
    """Loads all the images that are indexed in the initial csv and flips them horizontally+vertically using pytorch.
    The images are then saved in the same directory as image_dir_path, whith a flipped suffix (_h, _v or _hv).

    Args:
        initial_csv (str): Path to the initial csv file.
        image_dir_path (str): Directory where the images are stored.
        output_csv_path (str): Path to the output csv file.
    """
    
    # Input directories
    base_folder = Path(image_dir_path)
            
    # Load the images using the csv file
    with open(initial_csv, "r") as csvfile:
        
        reader = csv.reader(csvfile)
        header = next(reader)  # Skip the header row
        
        rows = list(reader)  # Read the rest of the rows
        new_rows = rows.copy()  # Copy the rows to a new list for the new csv file
        
        # the file id is the first column, the label is the rest of the columns
        for row in rows:
            
            file_name = "L" + str(row[0]) + ".JPG" 
            label = row[1:]
            
            # load the image and apply the flips
            img = Image.open(base_folder / (file_name)).convert("RGB")
            img_h = functional.hflip(img)
            img_v = functional.vflip(img)
            img_hv = functional.hflip(img_v)
            
            # save the images with the new names
            img_h.save(base_folder / (file_name[:-4] + "_h.JPG"))
            img_v.save(base_folder / (file_name[:-4] + "_v.JPG"))
            img_hv.save(base_folder / (file_name[:-4] + "_hv.JPG"))
            
            # add the new rows to the new csv file, the label is kept
            # if the file name starts with L, we remove it
            if file_name.startswith("L"):
                file_name = file_name[1:]
            # add the new rows to the new csv file
            new_rows.append([file_name[:-4] + "_h"] + label)
            new_rows.append([file_name[:-4] + "_v"] + label)    
            new_rows.append([file_name[:-4] + "_hv"] + label)
    
        # Save the new csv file
        with open(output_csv_path, "w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(header)
            writer.writerows(new_rows)


def apply_noise(image, probability=0.5, radius_min=0.3, radius_max=0.8):
    """Applies noise to the image with a certain probability. The noise is generated by applying a Gaussian blur to the image and then blending it with the original image.
    Args:
        image (PIL Image): The input image to which noise will be applied.
        probability (float, optional): Probability of applying noise. Defaults to 0.5.
        radius_min (float, optional): Minimum radius of the Gaussian blur. Defaults to 0.3.
        radius_max (float, optional): Maximum radius of the Gaussian blur. Defaults to 0.8.
    
    Returns:
        PIL Image: The image with noise applied.
    """
    
    radius = np.random.uniform(radius_min, radius_max)
    
    if np.random.rand() < probability:
        return image.filter(ImageFilter.GaussianBlur(radius))
    return image

    
def generate_synthetic_image(background, transparent_reference_path, image_size, noise=True):
    """Generates a synthetic image by pasting chocolates on a background image. The chocolates are randomly selected from a predefined list and their positions are determined to avoid overlap. The function also applies color jitter and noise to the chocolates if specified.
    Color jitter is applied when the the picture will be loaded in the torch dataset, so we don't need to apply it here.
    The function returns the generated image and a dictionary with the count of each chocolate type used in the image.

    Args:
        background (Image): PIL image object representing the background.
        transparent_reference_path (str): Path to the directory containing the chocolate images with transparency.
        image_size (tuple): Size of the generated image (width, height). Needed for the resizing of the reference chocolate
        noise (bool, optional): If True, applies noise to the chocolates. Defaults to True.

    Returns:
        (Image, dict): A tuple containing the generated synthetic image and a dictionary with the count of each chocolate type used.
    """
    
    # Where all the isolated chocolates are
    alpha_path = Path(transparent_reference_path)
    
    # Chocolate names to load
    chocolates = {"Jelly White": 0, "Jelly Milk": 0, "Jelly Black": 0, "Amandina": 0, "Crème brulée": 0, "Triangolo": 0, "Tentation noir": 0, "Comtesse": 0, "Noblesse": 0, "Noir authentique": 0, "Passion au lait": 0, "Arabia": 0, "Stracciatella": 0}
    chocolates_paths = []
    
    # Find the associated alpha images (requires precise naming in the transparent_reference_path)
    for choco in chocolates.keys():
        choco_name = choco.replace(" ", "_").replace("-", "_").replace("'", "_").replace("é", "e").replace("è", "e").lower()
        choco_path = alpha_path / (choco_name + ".png")
        if not choco_path.exists():
            print("Missing chocolate: ", choco_path)
            continue
        chocolates_paths.append(alpha_path / (choco_name + ".png"))
        
    # Scale them down to match the given image size
    scaled_chocolates = []
    for choco_path in chocolates_paths:
        # Open and resize the image
        img = Image.open(choco_path).convert("RGBA")
        # Now, we need to compute a scale factor since the chocolate where extracted from the original image that was 6000x4000px
        # The original chocolate size (alpha version) is 1200x800px
        x_ratio = image_size[0] / 6000
        y_ratio = image_size[1] / 4000
        new_size = (int(img.size[0] * x_ratio), int(img.size[1] * y_ratio))
        img = img.resize(new_size, Image.LANCZOS)
        # Apply noise if needed
        if noise:
            img = apply_noise(img, probability=0.6)    
        scaled_chocolates.append(img)
    
    # Convert the background to RGBA and get the dimensions
    background = background.copy().convert("RGBA")
    bg_w, bg_h = background.size
    
    # We create a binary mask to keep track of assigned pixels
    mask = np.zeros((bg_h, bg_w), dtype=np.uint8) 
    
    for _ in range(np.random.randint(0, 13)):
        
        i = np.random.randint(0, len(scaled_chocolates))
       
        # Variable to keep track of whether we found a spot for the chocolate, which need to be not overlapping with the others
        # Bounding box makes it to artifical, so we use the alpha channel to have the exact shape of the chocolate
        found_spot = False 
       
        while not found_spot:
           
            # random rotation (we want to have rotation, since it changes the geometry, we need to do it here)
            angle = np.random.randint(0, 360)
            candidate = scaled_chocolates[i].rotate(angle, expand=True)
            # flip the image with a probability of 0.5
            if np.random.rand() < 0.5:
                candidate = candidate.transpose(Image.FLIP_LEFT_RIGHT)
            if np.random.rand() < 0.5:
                candidate = candidate.transpose(Image.FLIP_TOP_BOTTOM)
            choco_w, choco_h = candidate.size
                        
            # Get x and y for the left top corner of the chocolate
            x = np.random.randint(0, bg_w - choco_w)
            y = np.random.randint(0, bg_h - choco_h)
            
            # get the alpha channel of the candidate chocolate
            target_region = mask[y : y + choco_h, x : x + choco_w]
            _, _, _, choco_alpha = candidate.split()
            choco_alpha = np.array(choco_alpha)
            
            # Check for collisions
            overlap = (choco_alpha > 0) & (target_region > 0)
            
            if np.sum(overlap) == 0:
                # No overlap, we can paste the chocolate
                found_spot = True
                
                # Update the mask with the new chocolate
                mask[y : y + choco_h, x : x + choco_w] = np.maximum(target_region, choco_alpha)
                
                # Paste the chocolate on the background
                background.paste(candidate, box=(x, y), mask=candidate)
                
                # Update the label for this chocolate
                chocolates[list(chocolates.keys())[i]] += 1
       
    result = background.convert("RGB")
    
    return result, chocolates


def generate_synthetic_dataset(num_images, backgrounds_path, transparent_reference_path, output_image_dir, previous_csv_path, output_csv_path, image_size, noise=True):
    """Generates a complete synthetic dataset of 'num_images' images. The images are generated by pasting chocolates on a background image.
    The chocolates are randomly selected from a predefined list and their positions are determined to avoid overlap.
    The function also applies noise to the chocolates if specified.

    Args:
        num_images (int): Number of images to generate.
        backgrounds_path (str): Path to the directory containing the background images.
        transparent_reference_path (str): Path to the directory containing the chocolate images with transparency.
        output_image_dir (str): Directory where the generated images will be saved.
        previous_csv_path (str): Path to the initial csv file that is goind to be augmented
        output_csv_path (str): Path to the output csv file (new generated image + previous ones). 
        image_size (tuple): Size of the generated image (width, height).
        noise (bool, optional): If we apply a noise to individuate chocolates in the . Defaults to True.
    """        

    output_dir = Path(output_image_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    backgrounds_path = Path(backgrounds_path)
    # get the pictures in the background folder
    backgrounds = sorted(backgrounds_path.glob("*.JPG"))
    num_backgrounds = len(backgrounds)
    # we split the number of images by the number of backgrounds
    num_images_per_background = num_images // num_backgrounds
    rest = num_images % num_backgrounds # for the last background

    # create the csv file
    with open(output_csv_path, "w", newline="") as csvfile:
        
        writer = csv.writer(csvfile)
        
        # header config
        # get the header from the preivous csv file, too lazy to rewrite all the chocolate names
        with open(previous_csv_path, "r") as prev_csvfile:
            prev_reader = csv.reader(prev_csvfile)
            header = next(prev_reader)
            
        writer.writerow(header)
        
        for i, background_path in enumerate(backgrounds):
            print("Generating images for background ", i+1, " of ", num_backgrounds)
            
            # load + resize the background image
            background = Image.open(background_path).convert("RGB")
            background = background.resize(image_size, Image.LANCZOS)
            
            n_image = num_images_per_background if i < num_backgrounds - 1 else num_images_per_background + rest
            
            # generate the images for this background
            for j in tqdm(range(n_image)):
                
                # generate the image
                synth, label = generate_synthetic_image(background, transparent_reference_path, image_size, noise=noise)
                
                # save the image
                file_name = "synth_bg" + str(i) + "_id" + str(j)
                file_path = output_dir / ("L" + file_name + ".JPG")
                synth.save(file_path)
                # write the label
                writer.writerow([file_name] + list(label.values()))
    

def merge_csv_files(input_csv1, input_csv2, output_csv):
    """Merges two CSV files into one. The first file is the one with the synthetic images, the second one is the one with the original images.
    The function assumes that the first column of both files is the image name and that the rest of the columns are the labels.

    Args:
        input_csv1 (str): Path to the first CSV file.
        input_csv2 (str): Path to the second CSV file.
        output_csv (str): Path to the output CSV file.
    """
    
    # Open both CSV files
    with open(input_csv1, "r") as csvfile1, open(input_csv2, "r") as csvfile2:
        
        reader1 = csv.reader(csvfile1)
        reader2 = csv.reader(csvfile2)
        
        # Read header and data
        header1 = next(reader1)
        header2 = next(reader2)
        
        rows1 = list(reader1)
        rows2 = list(reader2)
        
        # The header is the same for bot file, so we can just take the first one
        merged_header = header1
        
        # Merge rows
        merged_rows = rows1 + rows2
        
    # Write merged data to a new CSV file
    with open(output_csv, "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(merged_header)
        writer.writerows(merged_rows)
        
    print(f"Merged CSV files saved to {output_csv}.")