import os
from pathlib import Path
import csv
from PIL import Image, ImageFilter, ImageDraw
from torchvision.transforms import functional, v2
from tqdm import tqdm  # for progress bar
import numpy as np
import pandas as pd


def clear_output_dir(output_dir):
    """Deletes all the pictures in the output directory.
    Args:
        output_dir (str): Directory to clear.
    """
    
    # Iterate through all files in the directory
    for filename in os.listdir(output_dir):
        # Check if the file is a .jpg or .png file
        if filename.endswith(".jpg") or filename.endswith(".JPG"):
            file_path = os.path.join(output_dir, filename)
            try:
                if os.path.isfile(file_path):
                    os.remove(file_path)
            except Exception as e:
                print(f"Error deleting file {file_path}: {e}")
    
    print(f"All images in {output_dir} have been deleted.")


def apply_noise(image, probability=0.5, radius_min=0.3, radius_max=0.8):
    """Applies noise to the image with a certain probability. The noise is generated by applying a Gaussian blur to the image and then blending it with the original image.
    Args:
        image (PIL Image): The input image to which noise will be applied.
        probability (float, optional): Probability of applying noise. Defaults to 0.5.
        radius_min (float, optional): Minimum radius of the Gaussian blur. Defaults to 0.3.
        radius_max (float, optional): Maximum radius of the Gaussian blur. Defaults to 0.8.
    
    Returns:
        PIL Image: The image with noise applied.
    """
    
    radius = np.random.uniform(radius_min, radius_max)
    
    if np.random.rand() < probability:
        return image.filter(ImageFilter.GaussianBlur(radius))
    return image

    
def generate_synthetic_image(background, transparent_reference_path, noise=True):
    """Generates a synthetic image by pasting chocolates on a background image. The chocolates are randomly selected from a predefined list and their positions are determined to avoid overlap. The function also applies color jitter and noise to the chocolates if specified.
    Color jitter is applied when the the picture will be loaded in the torch dataset, so we don't need to apply it here.
    The function returns the generated image and a dictionary with the count of each chocolate type used in the image.

    Args:
        background (Image): PIL image object representing the background.
        transparent_reference_path (str): Path to the directory containing the chocolate images with transparency.
        noise (bool, optional): If True, applies noise to the chocolates. Defaults to True.

    Returns:
        (Image, dict): A tuple containing the generated synthetic image and a dictionary with the count of each chocolate type used.
    """
    
    # Where all the isolated chocolates are
    alpha_path = Path(transparent_reference_path)
    
    # Chocolate names to load
    chocolates = {"Jelly White": 0, "Jelly Milk": 0, "Jelly Black": 0, "Amandina": 0, "Crème brulée": 0, "Triangolo": 0, "Tentation noir": 0, "Comtesse": 0, "Noblesse": 0, "Noir authentique": 0, "Passion au lait": 0, "Arabia": 0, "Stracciatella": 0}
    chocolates_paths = []
    
    # Find the associated alpha images (requires precise naming in the transparent_reference_path)
    for choco in chocolates.keys():
        choco_name = choco.replace(" ", "_").replace("-", "_").replace("'", "_").replace("é", "e").replace("è", "e").lower()
        choco_path = alpha_path / (choco_name + ".png")
        if not choco_path.exists():
            print("Missing chocolate: ", choco_path)
            continue
        chocolates_paths.append(alpha_path / (choco_name + ".png"))
        
    # Scale them down to match the given image size
    scaled_chocolates = []
    for choco_path in chocolates_paths:
        # Open and resize the image
        img = Image.open(choco_path).convert("RGBA")
        # Apply noise if needed
        if noise:
            img = apply_noise(img, probability=0.6)    
        scaled_chocolates.append(img)
    
    # Convert the background to RGBA and get the dimensions
    background = background.copy().convert("RGBA")
    bg_w, bg_h = background.size
    
    # We create a binary mask to keep track of assigned pixels
    mask = np.zeros((bg_h, bg_w), dtype=np.uint8) 
    
    for _ in range(np.random.randint(1, 4)):
        
        i = np.random.randint(0, len(scaled_chocolates))
       
        # Variable to keep track of whether we found a spot for the chocolate, which need to be not overlapping with the others
        # Bounding box makes it to artifical, so we use the alpha channel to have the exact shape of the chocolate
        found_spot = False 
       
        while not found_spot:
           
            # random rotation (we want to have rotation, since it changes the geometry, we need to do it here)
            angle = np.random.randint(0, 360)
            candidate = scaled_chocolates[i].rotate(angle, expand=True)
            # flip the image with a probability of 0.5
            if np.random.rand() < 0.5:
                candidate = candidate.transpose(Image.FLIP_LEFT_RIGHT)
            if np.random.rand() < 0.5:
                candidate = candidate.transpose(Image.FLIP_TOP_BOTTOM)
            choco_w, choco_h = candidate.size
                        
            # Get x and y for the left top corner of the chocolate
            x = np.random.randint(0, bg_w - choco_w)
            y = np.random.randint(0, bg_h - choco_h)
            
            # get the alpha channel of the candidate chocolate
            target_region = mask[y : y + choco_h, x : x + choco_w]
            _, _, _, choco_alpha = candidate.split()
            choco_alpha = np.array(choco_alpha)
            
            # Check for collisions
            overlap = (choco_alpha > 0) & (target_region > 0)
            
            if np.sum(overlap) == 0:
                # No overlap, we can paste the chocolate
                found_spot = True
                
                # Update the mask with the new chocolate
                mask[y : y + choco_h, x : x + choco_w] = np.maximum(target_region, choco_alpha)
                
                # Paste the chocolate on the background
                background.paste(candidate, box=(x, y), mask=candidate)
                
                # Update the label for this chocolate
                chocolates[list(chocolates.keys())[i]] += 1
       
    result = background.convert("RGB")
    
    return result, chocolates


def generate_synthetic_dataset(img_per_bg, backgrounds_path, transparent_reference_path, output_image_dir, background_csv, noise=True):
    """Generates a complete synthetic dataset of 'num_images' images. The images are generated by pasting chocolates on a background image.
    The chocolates are randomly selected from a predefined list and their positions are determined to avoid overlap.
    The function also applies noise to the chocolates if specified.

    Args:
        img_per_bg (int): Number of images to generate per background.
        backgrounds_path (str): Path to the directory containing the background images.
        transparent_reference_path (str): Path to the directory containing the chocolate images with transparency.
        output_image_dir (str): Directory where the generated images will be saved.
        background_csv (pd.Dataframe): Dataframe containing all the labels for the background images.
        noise (bool, optional): If we apply a noise to individuate chocolates in the . Defaults to True.
        
    Returns:
        pd.DataFrame: Dataframe containing the labels for the generated images.
    """        
    

    # Create the output directory if it doesn't exist
    output_dir = Path(output_image_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    clear_output_dir(output_image_dir)
            
    backgrounds_path = Path(backgrounds_path)
    
    # keep only the structure, remove the content of the output csv
    output_csv = pd.DataFrame(columns=background_csv.columns)
    
    # we Iterate on the csv's role, which represents the background images
    for i, row in tqdm(background_csv.iterrows(), total=background_csv.shape[0], desc="Generating synthetic images"):
        
        # Load the background image
        background_name = row.values[0]
        background_path = backgrounds_path / ("L" + background_name + ".JPG")
        background = Image.open(background_path).convert("RGB")
    
        for j in range(img_per_bg):
            # Create a synthetic image
            synth, label = generate_synthetic_image(background, transparent_reference_path, noise=noise)
            
            # Convert the label to a numpy array            
            label = np.array(list(label.values()))
            
            # Save the synthetic image
            file_name = "synth_bg" + str(i) + "_id" + str(j)
            file_path = output_dir / ("L" + file_name + ".JPG")
            synth.save(file_path)
            
            # get the previous label as numpy array
            previous_label = np.array(background_csv.iloc[i, 1:]).astype(int)
            
            # Merge the two labels
            label = np.add(label, previous_label)
            output_csv = pd.concat([output_csv, pd.DataFrame([[file_name] + list(label)], columns=background_csv.columns)], ignore_index=True)
            
    return output_csv